--- 
layout: post
title: Shame On Me
date: 2008-2-27
comments: true
link: false
---
<p>Someone decided to publicly criticize my example code in my previous post by saying that it was &ldquo;bad.&rdquo;&nbsp; While I don&rsquo;t agree with the nature of the criticism (my blog *does* have comments, you know) I totally agree with the message.&nbsp; It was bad code.&nbsp; I would never place that in a production application.</p><p>The intent of the post was to demonstrate some ajax techniques, not to talk about how to write testable, decoupled&nbsp;controllers.&nbsp; I suppose that example code should come with a bit of a disclaimer that says <em>&ldquo;hey, we are doing this here for simplicity&rsquo;s sake, but obviously you&rsquo;d abstract this out.&rdquo;&nbsp; </em>Ideally I would have commented out the entire flickr section, because it&rsquo;s totally not important in the context of the example.</p><p>In light of this topic, here is how a perfectly testable PhotosController might be written:</p><p>`{% codeblock %}public class PhotosController : Controller{private readonly IPhotoRepository _photoRepository;public PhotosController(IPhotoRepository photoRepository){_photoRepository = photoRepository;}[ControllerAction]public void Search(){RenderView("Search", new Photo[] { });}[ControllerAction]public void Find(string query, bool? ajax){ var photos = _photoRepository.SearchPhotos(query);ViewData["query"] = query;ViewData["photos"] = photos;if(ajax == true){RenderView("_images", photos);}else{RenderView("results");}}}{% endcodeblock %}`<p>Here you can clearly see our dependency on IPhotoRepository.&nbsp; This guy can be anything we want, from a Flickr implementation, google images implementation, a file system directory, or even (gasp) a TEST implementation for writing unit tests!</p><p>Here is the IPhotoRepository, that we are using in the example:</p><p>`{% codeblock %}public interface IPhotoRepository{Photo[] SearchPhotos(string query);<p>asdf</p>}{% endcodeblock %}`<p>This returns a Photo object (that I defined), which means whatever implementation you choose, you need to map to this object. This is a good thing because it removed my dependency on "FlickrPhoto" in the view itself.</p><p>Our FlickrPhotoRepository now looks like this:</p>`{% codeblock %}public class FlickrPhotoRepository : IPhotoRepository{private readonly IConfigSource _ConfigSource;public FlickrPhotoRepository(IConfigSource configSource){_ConfigSource = configSource;}public Photo[] SearchPhotos(string query){var flickr = new Flickr(_ConfigSource.GetSetting("flickr.api.key"));var results = flickr.PhotosSearch(query, TagMode.AnyTag, query, 40, 1);var photos = new List&lt;Photo&gt;();foreach (var item in results.PhotoCollection){photos.Add(new Photo(item.SquareThumbnailUrl, item.Title, item.PhotoId));}return photos.ToArray();}}{% endcodeblock %}`<p>Wait a minute! This class now has it's own dependency on IConfigSource? Craziness! In our example code from before, I had accessed the Configuration singleton directly, which is punishable by hand-removal in Albonia. Thank goodness I don't live there. Now this class is decoupled from the actual configuration implementation and it could really be coming from a text file or database (whatever you want). <p>Wiring all this up is easy.&nbsp; You could do it via XML, but I chose to do it directly in code: `{% codeblock %}private void InitializeWindsor(){_container = new WindsorContainer();_container.AddComponent("config-source", typeof(IConfigSource), typeof(AppDomainConfigSource));foreach(Type type in Assembly.GetExecutingAssembly().GetTypes()){ if(type.IsSubclassOf(typeof(Controller))){_container.AddComponent(type.Name, type);}}}{% endcodeblock %}`<p>Also note that I'm using WindsorControllerFactory from MVCContrib, so now my controller can be created (and each of it's dependencies ( and their dependencies (and their Dependencies)))... I think you get the idea.</p><p>And there you have it.&nbsp; A perfectly decoupled and testable modification for my previous example code.&nbsp; <em>As you were&hellip;.</em></p>
