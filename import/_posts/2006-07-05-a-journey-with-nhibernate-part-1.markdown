--- 
layout: post
title: A Journey with NHibernate - Part 1
date: 2006-7-5
comments: true
link: false
---
<p>In this series of articles, I am going to dive into some topics with NHibernate.&nbsp; There is a lot of beginner information on the internet, but not a whole lot of real-life examples.&nbsp;&nbsp; I’ve seen countless exaples where the author builds a session factory, creates a session, and does some persistence all inside a single method or block of code.&nbsp; This is of course ludicrous for real projects.&nbsp; This is something I’d like to address.&nbsp; I’ll try to focus on things like proper object-oriented design and testability with your projects.</p><p>In the first few articles, we will see how to start projects using NHibernate, go over some basic topics, and then get progressively more complex as we explore the many features of the ORM tool.</p><p>If you don’t know what NHibernate is, I’d suggest <a title="google search for nhibernate" href="http://www.google.com/search?q=nhibernate" target="_blank">a google search</a>&nbsp;or going to the <a href="http://hibernate.org/" target="_blank">NHibernate home page</a>.</p><p>…..go ahead, I’ll wait…..</p><p>Ok, so you know what NHibernate does, and you’re convinced you want to use it.&nbsp; What next?&nbsp; First we have to understand how to “properly” structure your project.</p><p><em>(Side note:&nbsp; I say ‘properly’ in quotes because some will disagree with me.&nbsp; There are 2 very distinct camps when it comes to designing domain objects for persistence.&nbsp; One camp follows an active record (class-in-charge)&nbsp;approach to persistence (such as <a href="http://www.castleproject.org/index.php/ActiveRecord" target="_blank">Castle’s ActiveRecord</a> and <a href="http://www.lhotka.net/ArticleIndex.aspx?area=CSLA%20.NET%2020" target="_blank">CSLA.NET</a>).&nbsp; These folks prefer to encapsulate all of the persistence inside of the object itself.&nbsp; I started off with this mentality, but quickly got annoyed with all of the persistence code within my domain model.&nbsp; I have since sided with the POCO/PI (Plain-Old-CLR-Objects / Persistence-Ignorant) objects where your objects are completely separated from their persistence.&nbsp; I think this leads to code that is easier to test, less-cluttered, and decoupled from infrastructure concerns.&nbsp; This leaves only business logic, which is the most important concern to any project.&nbsp; In this article I am going to focus on PI objects, however most of the content will be relative to an active record approach).</em></p><p>I will start out by creating the project structure:</p><ul><li><strong>Project.DomainModel </strong>(business objects / logic)</li><li><strong>Project.Persistence&nbsp; </strong>(data access strategy)</li><li><strong>Project.Utilities&nbsp; </strong>(project-wide utilities)</li><li><strong>Project.Web.UI&nbsp; </strong>(web front-end, if any)</li><li><strong>Project.Win.UI&nbsp;&nbsp; </strong>(windows front-end, if any)</li><li><strong>Project.DomainModel.Tests </strong>(tests for the domain model)</li><li><strong>Project.Persistence.Tests </strong>(tests for the persistence layer.)</li></ul><p>To ensure that the domain model knows nothing of persistence, I will make sure not to add the reference to the Persistence project or any NHibernate dlls.&nbsp; Now, we can add the reference to the NHibernate dll to the Persistence project.</p><p>The test projects, as you can see, are separated based on what they test.&nbsp; Why is this?&nbsp; Because your main tests are going to be testing the logic and behavior of the domain model.&nbsp; It is imperative that these tests run quickly.&nbsp; If you keep the slower tests separate, it keeps developers more productive (and more likely to run the tests!).&nbsp; The persistence tests will actually hit the database, and so they will be *much* slower.&nbsp; We’ll see this later on.</p><p>On any object-oriented domain model, you should try to develop&nbsp;your objects&nbsp;without concern for the database.&nbsp; That is, develop and test the behavior of your objects before you even go to save them to the database.&nbsp; There are many benefits to programming this way:</p><ul><li><strong>Your code is more testable<br></strong>Code that doesn’t depend on many things is easier to test.&nbsp; The data access portion is a large example of this.&nbsp; You should be able to test object interaction entirely without hitting a database.</li><li><strong>Your knowledge of the domain increases as you go<br></strong>You aren’t ever going to understand every minute detail of an application before you write it.&nbsp; No matter how much up-front design you do, you’ll always end up getting stumped and&nbsp;running into a road-block, or your understanding of the problem domain will evolve.&nbsp; This is expected and embraced when you are practicing Test Driven Development.&nbsp; Your code changes are backed up by unit tests which tell you if the code is working.&nbsp; If you leave out the database in this loop, you return to a a functioning domain a lot quicker.&nbsp; Implement the database once your design has settled down some more.</li><li><strong>Your persistence layer can be substituted with minimal impact to program behavior<br></strong>If you decide at some point that you’d rather go with a different ORM, or hand-craft the data access portion you can do that.&nbsp; You don’t have to worry about your changes affecting program behavior, as long as you fulfill the responsibilities of the data access layer.</li></ul><p>I think that we have a good overview of NHibernate and how it fits nicely with Domain Driven Design.&nbsp; In the next article we’ll get more concrete and actually start a fictitous project using NHibernate and .NET 2.0.</p><p>Until next time….<br></p>
