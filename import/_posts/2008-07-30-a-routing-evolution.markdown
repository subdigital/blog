--- 
layout: post
title: A Routing Evolution
date: 2008-7-30
comments: true
link: false
---
<p><a href="http://flux88.com/uploads/ARoutingEvolution_12D7B/216624forkinroadposters.jpg"><img src="/images/216624forkinroadposters_thumb_.jpg" alt="216624fork-in-road-posters"  border="0" /></a> When the ASP.NET MVC framework was first released, two open source projects sprung up immediately:&nbsp; <a href="http://mvccontrib.org" target="_blank">MVCContrib</a> and <a href="http://codecampserver.org" target="_blank">Code Camp Server</a>.&nbsp; I quickly jumped on Code Camp Server as a lead contributor because I wanted to get some hands on experience on the ASP.NET MVC Framework.</p> <p>In the first example you see when you install the new MVC templates, you see that the default routing rules are defined like this:</p>{% codeblock %}{controller}/{action}/{id}{% endcodeblock %}<p>This works well for a lot of applications, where you'd end up with URLs like:</p>{% codeblock %}/customers/list<br>/customers/delete/12<br>/products/show/5<br>/products/edit/5{% endcodeblock %}<p>It's quite easy to see how each of those map to the components of the route.&nbsp; In Code Camp Server, we wanted the system to support many code camps, so your URL will look like this:</p><p>/austinCodeCamp/details<br>/houstonTechFest/directions</p><p>So we ended up with a default route that looked like this:</p>{% codeblock %}routes.MapRoute("conference", "{conferenceKey}/{action}", new { controller="conference", action="details });{% endcodeblock %}<p>Here we omitted the controller as it was <em>implied</em>.&nbsp; Everything was placed on ConferenceController, and it worked pretty well to start out.&nbsp; Then we started adding actions like Sessions, and ListAttendees, and started to notice that those things probably belong on their own controllers.&nbsp; </p><p>But we had a problem... if I have a URL like this:</p>{% codeblock %}/houstonTechFest/sessions{% endcodeblock %}<p>this will translate to an action called "sessions" on the conference controller.&nbsp; That's not what we want.&nbsp; So we started to hard code these specific instances like this....</p>{% codeblock %}routes.MapRoute("speakers", "{conferenceKey}/speakers/{action}", new {controller = "speaker", action = "list"});<br>routes.MapRoute("schedule", "{conferenceKey}/schedule/{action}", new {controller = "schedule", action = "index"});<br>routes.MapRoute("sessions", "{conferenceKey}/sessions/{action}", new {controller = "session", action = "list"});<br>routes.MapRoute("sponsors", "{conferenceKey}/sponsors/{action}", new {controller = "sponsor", action = "list"});{% endcodeblock %}<p>YUCK.&nbsp; Things are starting to get really hairy now.</p><p>So, after a phone call with <a href="http://jeffreypalermo.com/" target="_blank">Jeffrey Palermo</a>, he raised the question:</p><blockquote><p><em>"Why even have the default point to conference controller?&nbsp; The only common action on that is Details.&nbsp; All of the rest are separate controllers."</em></p></blockquote><p>And then it clicked.&nbsp; We can now change the route definition to this:</p>{% codeblock %}routes.MapRoute("standard", "{conferenceKey}/{controller}/{action}/{id}", new { controller="conference", action="index", id=(string)null});{% endcodeblock %}<p>Which produces these very acceptable URLs:</p><table cellspacing="0" cellpadding="2" width="400" border="1"><tbody><tr><td valign="top" width="100"><strong>URL</strong></td><td valign="top" width="100"><strong>Controller</strong></td><td valign="top" width="100"><strong>Action</strong></td><td valign="top" width="100"><strong>Id</strong></td></tr><tr><td valign="top" width="100">/houstonTechFest</td><td valign="top" width="100">Conference</td><td valign="top" width="100">Index</td><td valign="top" width="100">&nbsp;</td></tr><tr><td valign="top" width="100">/houstonTechFest/sessions</td><td valign="top" width="100">Sessions</td><td valign="top" width="100">Index</td><td valign="top" width="100">&nbsp;</td></tr><tr><td valign="top" width="100">/houstonTechFest/sessions/add</td><td valign="top" width="100">Sessions</td><td valign="top" width="100">Add</td><td valign="top" width="100">&nbsp;</td></tr><tr><td valign="top" width="100">/houstonTechFest/sponsors/edit/5</td><td valign="top" width="100">Sponsors</td><td valign="top" width="100">Edit</td><td valign="top" width="100">5</td></tr></tbody></table><p>there are a few extra cases where we don't want to start with a conference key (for example, /conference/list, /conference/current, /login, /admin, etc...).&nbsp; These URLs all work with the standard route, so we can define that just below our first route.</p>{% codeblock %}routes.MapRoute("conference", "{controller}/{action}/{id}",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new {controller="conference", action="list"});{% endcodeblock %}<p>Now the URL /conference/list (and the others) will get routed properly with this definition.&nbsp; </p><p>Now there's just one final problem.&nbsp; Can you see it?&nbsp; If we define the other route first, then the first token of the route will get picked up as a conference key!&nbsp; We certainly don't want that.&nbsp; So we'll add a constraint to the first route to match everything except the controllers we want to address specifically.&nbsp; Our route now looks like...</p>{% codeblock %}routes.MapRoute("confkey", "{conferenceKey}/{controller}/{action}/{id}",new { controller="conference", action="index", id=(string)null },new { conferenceKey="(?!conference|admin|login).*"});routes.MapRoute("standard", "{controller}/{action}/{id}",new { controller="conference", action="index", id=(string)null });{% endcodeblock %}<p>The first route will grab everything except those URLs that start with "conference", "admin", or "login."&nbsp; There might be other controllers, but this is all we need for now.&nbsp; Those URLS get picked up by the 2nd route and everything works fine after that.</p><p>Coming up with a clear set of routes that don't conflict with each other is very difficult once you stray away from the norm.&nbsp; The more route definitions you have, the more care you have to take to ensure that the new rule doesn't break a whole slew of existing URLs.&nbsp;&nbsp; This is critically important if you already have an application in production.&nbsp; A simple change in the Global.asax file can change all of the URL's for your application!&nbsp; That's like <a href="http://en.wikipedia.org/wiki/Paraquat" target="_blank">paraquat</a> for <a href="http://c2.com/cgi/wiki?GoogleJuice" target="_blank">Google Juice</a>.</p><h3>Testing the Routes</h3><p>Unit tests can surely help here.&nbsp; For these examples, I followed a simple technique for testing my routes.&nbsp; First is the method to fake out the actual request:</p>{% codeblock %}<span class="kwrd">private</span> <span class="kwrd">static</span> RouteData getMatchingRouteData(<span class="kwrd">string</span> appRelativeUrl){RouteTable.Routes.Clear();var configurator = <span class="kwrd">new</span> RouteConfigurator();configurator.RegisterRoutes();RouteData routeData;var mocks = <span class="kwrd">new</span> MockRepository(); var httpContext = mocks.DynamicMock&lt;HttpContextBase&gt;();var request = mocks.DynamicMock&lt;HttpRequestBase&gt;();<span class="kwrd">using</span> (mocks.Record()){SetupResult.For(httpContext.Request).Return(request);mocks.Replay(httpContext);SetupResult.For(httpContext.Request.AppRelativeCurrentExecutionFilePath).Return(appRelativeUrl);SetupResult.For(httpContext.Request.PathInfo).Return(<span class="kwrd">string</span>.Empty);}<span class="kwrd">using</span> (mocks.Playback()){routeData = RouteTable.Routes.GetRouteData(httpContext);}<span class="kwrd">return</span> routeData;}{% endcodeblock %}<p>Now we can have a simple helper method for asserting that are routes produce the right tokens:</p>{% codeblock %}<span class="kwrd">private</span> <span class="kwrd">void</span> AssertRoute(<span class="kwrd">string</span> virtualPath, <span class="kwrd">string</span> expectedController, <span class="kwrd">string</span> expectedAction, IDictionary&lt;<span class="kwrd">string</span>,<span class="kwrd">string</span>&gt; expectedTokens){var routeData = get
MatchingRouteData(virtualPath);Assert.That(routeData.GetRequiredString(<span class="str">"controller"</span>), Is.EqualTo(expectedController));Assert.That(routeData.GetRequiredString(<span class="str">"action"</span>), Is.EqualTo(expectedAction));<span class="kwrd">foreach</span> (var pair <span class="kwrd">in</span> expectedTokens){Assert.That(routeData.GetRequiredString(pair.Key), Is.EqualTo(pair.Value));}}{% endcodeblock %}<p>And finally the tests that I'm running to ensure these routes are working properly...<p><!-- code formatted by http://manoli.net/csharpformat/ -->{% codeblock %}[Test]<span class="kwrd">public</span> <span class="kwrd">void</span> TestSiteRoutes(){AssertRoute(<span class="str">"~/austinCodeCamp2008"</span>, <span class="str">"conference"</span>, <span class="str">"index"</span>,<span class="kwrd">new</span> Dictionary&lt;<span class="kwrd">string</span>, <span class="kwrd">string</span>&gt; {{<span class="str">"conferenceKey"</span>, <span class="str">"austinCodeCamp2008"</span>}});AssertRoute(<span class="str">"~/login"</span>, <span class="str">"login"</span>, <span class="str">"index"</span>);AssertRoute(<span class="str">"~/conference/new"</span>, <span class="str">"conference"</span>, <span class="str">"new"</span>);AssertRoute(<span class="str">"~/conference/current"</span>, <span class="str">"conference"</span>, <span class="str">"current"</span>);AssertRoute(<span class="str">"~/admin"</span>, <span class="str">"admin"</span>, <span class="str">"index"</span>);AssertRoute(<span class="str">"~/houstonTechFest/sessions/add"</span>, <span class="str">"sessions"</span>, <span class="str">"add"</span>,<span class="kwrd">new</span> Dictionary&lt;<span class="kwrd">string</span>,<span class="kwrd">string</span>&gt; {{<span class="str">"conferenceKey"</span>, <span class="str">"houstonTechFest"</span>}});}{% endcodeblock %}<p>This is only half of the story though.&nbsp; You should also test that the routes you ask for (like with Html.ActionLink and Url.Action) produce the intended URLs.&nbsp; Otherwise you may have URLs that match routes, but routes that don't match your intended URLs.</p><p>Testing these is a bit harder, and it's 1am now... so I'll take the ultimate cop-out and <em>leave it as an exercise to the reader</em>. </p>
