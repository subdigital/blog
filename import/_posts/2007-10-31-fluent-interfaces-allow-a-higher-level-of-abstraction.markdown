--- 
layout: post
title: Fluent Interfaces Allow a Higher Level of Abstraction
date: "2007-10-31"
comments: true
link: false
---
<p><a href="http://www.codinghorror.com/blog/archives/000989.html" target="_blank">Jeff Atwood</a> takes a stand against using embedded languages to express intent.I concur with <a href="http://www.ayende.com/Blog/archive/2007/10/31/Embracing-fluent-interfaces.aspx" target="_blank">Ayende's response</a> for most of his points, however I wanted to chime in on the discussion.</p><p>Later on, Jeff argues that a better way (or as he puts it, the <b>"ultimate solution"</b>) is to include the underlying features of other languages to leverage them natively.He specifically mentions LINQ.Take a look at this sample LINQ syntax:</p><p></p>{% codeblock %}var priorityCustomers = from customer in Customers<br>			where customer.Status = 'Gold'<br>			select customer;{% endcodeblock %}<p></p><p>This syntax is great, and I welcome it for VS 2008.But this is almost the same thing as the Criteria API in NHibernate, or the Querying API in SubSonic.The only difference is that we're not using parentheses and dots all over the place, but the end result is the same.</p><p>Having this code directly in our language also makes it more difficult to construct dynamic queries.By dynamic I don't mean make the <em>'Gold'</em> text a parameter, I'm talking about building the where clause dynamically based on run-time decisions.Using a query builder API such as SubSonic's allows you to do this.</p><p>Another point that Atwood makes is that creating fluent interfaces over things like regexes and SQL allows you to NOT learn the underlying concepts, which is unacceptable for professional developers.I agree with him, but LINQ is also one of those!The syntax we wrote above will get translated into a real T-SQL query for us.We should still be cognizant of the SQL that is generated and make adjustments where necessary, but does that mean we always have to program at the lowest common denominator?As professional developers we have to be aware of many technical concepts that are being abstracted from us.A lot of us program in .NET, and most of us probably have a background in C++.I'm glad I learned C++ so that I understand what's going on "behind the curtain," but I'm programming at a higher level of abstraction now.Remember having to always null-terminate your strings (I mean char arrays)?.I'm glad I don't have to do that anymore.Working at a higher level of abstraction allows me to be more productive.</p><p>The languages that we see in the coming years will almost certainly bost higher layers of abstraction and specialty, so that we can more easily build data-driven business applications, or 3D-modeled geology simulations, or whatever your domain is.AT&amp;T has <a href="http://blog.wired.com/27bstroke6/2007/10/att-invents-pro.html" target="_blank">just created a programming language called Hancock</a>, specifically geared for mass surveylance.ERLang is designed specifically for mission-critical, always-on systems.&nbsp; There are many that exist today and even more that we haven't seen yet.&nbsp; Don't fear the abstractions!<br></p>
