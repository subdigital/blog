--- 
layout: post
title: The Transition from TDD to BDD
date: "2008-10-12"
comments: true
link: false
---
<p><a href="http://flux88.com/uploads/TheTransitionfromTDDtoBDD_13B13/butterfly.jpg"><img src="/images/butterfly_thumb_.jpg" alt="butterfly"  border="0" /></a> I've been a long practitioner of test-driven development (TDD). I first started unit testing back in 2004, and it made a profound effect on me.&nbsp; It was incredibly difficult, however and I began to look for ways to make my code more testable. This brought me to TDD, which guided me towards looser-coupled systems that were testable from the get-go (since we started out testing it!)</p> <p>Things in the TDD world aren't all peach schnapps and roses (or however the saying goes). Often times you still end up with messy tests that have tons of code duplication and very little solubility. TDD is still difficult for me, even though I've done it for 4 years.</p> <p>One thing I've noticed lately that I've been slowly losing in my tests is the executable documentation. It's increasingly hard to tell how my system behaves just from reading my unit tests. As our system grew more complex, so did our unit tests and eventually they lost most of their grokability.</p> <p>Another thing I've noticed is that our tests have so much setup gunk that it clouds the meaning of each test method. By nature each test likely has some particular context in which it intends to run, and this code gets placed in the [Test] itself rather than the [SetUp]. Why?&nbsp; My mocks need to behave differently in each test method, so if I put them in the setup, things either don't work for other tests or there are mocks being set up that are never used for other tests. I directly attribute this to having one [TestFixture] per system under test.</p> <p>I'd like to state that again, because it bears repeating. <strong>One TestFixture per system under test is an anti-pattern.</strong> It has taken me three (3!) presentations on Behavior-Driven Design for this fact to really sink in.&nbsp; Contexts are important, and a system that you want to test certainly has more than one context. By separating the fixtures into per-system-context rather than per-system, we can now leverage our [Setup] again to establish our context!</p> <p>Here is a test class that I might have written with a strict TDD mindset:</p>{% codeblock %}//PostControllerTester.cs{% endcodeblock %}{% codeblock %}[Test]<br>public void edit_action_gets_post_from_repository()<br>{<br>&nbsp;&nbsp;&nbsp; _authService.Stub(x=&gt;x.IsAuthorizedToEdit("bob"))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .IgnoreArguments()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Return(true); <p>&nbsp;&nbsp;&nbsp; var controller = CreatePostController();<br>&nbsp;&nbsp;&nbsp; controller.Edit(5);<br>&nbsp;&nbsp;&nbsp; _repository.AssertWasCalled(x=&gt;x.Find(5));<br>}</p>{% endcodeblock %}<p>Notice that this test actually has some setup, some sort of action (in this case we're invoking the Edit action), and some verification.&nbsp; This test has 3 pieces to it!&nbsp; Applying a more BDD mindset, you'd likely have something like this:</p>{% codeblock %}public class when_invoking_edit_action_as_authorized_user()<br>{<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; [SetUp]<br>&nbsp;&nbsp;&nbsp; public void Setup<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _controller = new PostsController(...);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _authService = MockRepository.GenerateMock&lt;IAuthService&gt;();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _repository = MockRepository.GenerateMock&lt;IPostRepository&gt;();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EstablishContext();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; public void EstablishContext()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _authService.Stub(x=&gt;x.IsAuthorizedToEdit("bob"))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .IgnoreArguments().Return(true);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; public void When()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _controller.Edit(5);&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; [Test]<br>&nbsp;&nbsp;&nbsp; public void it_should_fetch_post_from_repository()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _repository.AssertWasCalled(x=&gt;x.Find(5));<br>&nbsp;&nbsp;&nbsp; }<br>} {% endcodeblock %}<p>Notice the name of the class.&nbsp; It describes the context of what we're trying to accomplish.&nbsp; Our [SetUp] now establishes the state of the environment in which we want to act on our system.&nbsp; The When() method is where we act on our system.&nbsp; The only thing remaining is the test which is now dead simple.&nbsp; The test simply verifies some aspect of the system.&nbsp; The name of the test is also only conveying the verification part of the test.</p><p>We can now easily glance at this test (or spec, which it is sometimes called) and read it like english:</p><blockquote><p>When invoking the edit action as an authorized user, it should should fetch the post from the repository.</p></blockquote><p>This looks awfully close to acceptance criteria that we write for our user stories.&nbsp; </p><p>Any acceptance tests that share the same context can reside in the same fixture.&nbsp; It's perfectly normal to have 1 test per fixture, but at times you'll find that you can have 2 or 3 that indeed share the same context, and those can reside in the same fixture class.</p><p>&nbsp;</p><h3>BDD Frameworks</h3><p>There are plenty of BDD frameworks out there that will do their best to impose their view of BDD on you, and this can seriously hinder your ability to naturally understand the why/how of BDD.&nbsp; Later on, once you have your own opinions, you can leverage a framework (such as MSpec) to have a more terse syntax for describing behaviors in your system.</p><h3>BDD Base Class</h3><p>Until you get BDD, stick to what you know.&nbsp; In my example I call EstablishContext() and When(), and I'll do that for every fixture.&nbsp; Why not leverage a base class?&nbsp; Here's mine:</p>{% codeblock %}public abstract class Specification<br>{<br>&nbsp;&nbsp;&nbsp; protected Exception ExceptionThrown { get; private set; } <p>&nbsp;&nbsp;&nbsp; <br>[SetUp]<br>&nbsp;&nbsp;&nbsp; public void Setup()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EstablishContext(); <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch(Exception exc)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionThrown = exc;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; } <p>&nbsp;&nbsp;&nbsp; </p><p>protected T Mock&lt;T&gt;()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MockRepository.GenerateMock&lt;T&gt;();<br>&nbsp;&nbsp;&nbsp; } </p><p>&nbsp;&nbsp;&nbsp; protected abstract void EstablishContext();<br>&nbsp;&nbsp;&nbsp; protected abstract void When(); <p>&nbsp;&nbsp;&nbsp; </p><p>[TearDown]<br>&nbsp;&nbsp;&nbsp; public virtual void TearDown()<br>&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; }<br>}</p>{% endcodeblock %}<p>Now when you inherit from Specification, you are forced to provide implementations of EstablishContext() and When().&nbsp; I also wrap the When() in a try/catch so that you can do things like Assert.WasThrown(...);</p><h3>The BDD Journey</h3><p>I'm still a BDD newbie, but I'm now sold on it's organizational structure and it's ability to connect tests back to actual requirements of the system.&nbsp; It provides a clear picture of how to group tests &amp; setup behaviors and combined with the
new RhinoMocks AAA syntax, makes my tests much easier to read.</p><p>The tipping point for me was attending <a href="http://codebetter.com/blogs/raymond.lewallen/" target="_blank">Raymond Lewallen</a>'s BDD talk at <a href="http://techfests.com/tulsa/2008" target="_blank">Tulsa TechFest</a>.&nbsp; I recorded the first hour of it, and <a href="http://www.viddler.com/explore/PhatBoyG/videos/1/" target="_blank">it's available up on Viddler</a>.&nbsp; I hope this helps more people understand BDD.&nbsp; I've seen presentations like this before, but it took some practice (and failure!) on my own time to start to see some speed bumps.&nbsp; With this knowledge I was able to ask some direct questions and get (gasp!) direct answers.</p><p>While I cannot justify going back and changing 500 or so unit tests to this form, I will ensure that I start writing BDD style specifications for my new production code moving forward. </p>
