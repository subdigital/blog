<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby, | Fickle Bits]]></title>
  <link href="http://benscheirman.com/blog/categories/ruby-/atom.xml" rel="self"/>
  <link href="http://benscheirman.com/"/>
  <updated>2012-07-07T16:09:13-05:00</updated>
  <id>http://benscheirman.com/</id>
  <author>
    <name><![CDATA[Ben Scheirman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Is Rails Exempt?]]></title>
    <link href="http://benscheirman.com/2011/08/is-rails-exempt-from-software-principles/"/>
    <updated>2011-08-26T07:58:00-05:00</updated>
    <id>http://benscheirman.com/2011/08/is-rails-exempt-from-software-principles</id>
    <content type="html"><![CDATA[<p>If you've been following the Ruby community recently, you'd notice that
there's are people calling our Rails (and Rails developers) for treating
Rails as if it is somehow <em>exempt</em> from long-standing software
principles.</p>

<p><a href="http://osherove.com/">Roy Osherove</a>, a fairly well-known .NET developer and author of The <a href="http://artofunittesting.com/">Art of Unit Testing</a>, ventured into Ruby-land
recently and commented on twitter about how Rails's
definition of unit &amp; integration is quite different from his.</p>

<p><img class="tweet" src="/images/rails-unit-integration-tweet.png"></p>

<p>I have to agree with Roy. Those in the TDD camp in .NET understood the
difference and were (from my experience) fairly cognizent of isolating
concerns and not mixing the 2 concepts. Some even go as far as to
isolate integration tests into their own assembly, providing a physical
separation further guaranteeing that a unit test project won't touch
web services or the database.</p>

<p>It's easy to assume from the outside that the Rails is just testing
nirvana and that <em>everyone</em> does it and it's so easy.  Unfortunately it's
just not the truth.  Rails (and Ruby) make testing really easy but that
means it's even easier to do the wrong thing as well.</p>

<h2>Legacy Rails Apps</h2>

<p>Now that Rails is (gasp) over 7 years old you're starting to see some
real legacy Rails applications out in the wild.</p>

<p><a href="http://twitter.com/avdi">Avdi Grimm</a> has a <a href="http://avdi.org/devblog/2011/08/22/your-code-is-my-hell/">good post</a> on the topic of how many of the Rails apps he comes to work on are in poor shape, technically.</p>

<blockquote><p>Here are a few examples, just to give you an idea of what I’m talking about:</p>

<p>“Design Patterns are a Java thing. In Ruby you just write code.”</p>

<p>“The warnings Ruby produces are dumb; just disable them.”</p>

<p>“Sure they aren’t technically Unit Tests, but isolating objects turned out to be kind of hard and besides nobody else is doing it.”</p>

<p>“Stuff like the Law of Demeter isn’t really as important in Ruby code”</p>

<p>“That’s only a problem in large projects” (implying that this project will never become large).</p></blockquote>

<p>I've certainly been guilty of some of this. Rails makes it easy to do
things that can turn out to be problematic. As with anything, you have
to be disciplined to notice the warning signs and act accordingly.</p>

<p>When testing is painful, you're likely making mistakes. Some common
pain-points that I've experienced are:</p>

<ul>
<li>No tests - the app is hard to test because the design is poor. Classes
are too tightly coupled and don't have clear delineation of
responsibilities.</li>
<li>Tests break for unrelated reasons - the tests are covering too much
behavior, so when a single behavior changes, many tests break.</li>
<li>Tests break when implementation changes - the tests are probably
utilizing too much mocking &amp; stubbing. The tests are coupled heavily
to a particular implementation.</li>
<li>Unclear what the problem is when a test breaks - Tests are probably
too coarse-grained and may contain too many assertions per test.</li>
</ul>


<p>These are just a sampling of what I've personally observed.</p>

<p>So why do many Rails developers ignore these concepts?</p>

<h2>Pragmatism at work</h2>

<p>Many rails tutorials (and the default Rails template) treats model tests
as <em>unit</em> tests. Since Rails models are by default based on Active
Record, they have data access baked into their core.  Doing proper unit
testing means you're testing a logical unit.  If your test involves a
model operation that requires a database round-trip, that's technically
an <em>integration</em> test.  But does it really matter?</p>

<p>Most Rails developers will tell you no. Consider this spec:</p>

<p>```ruby</p>

<pre><code>describe Post do
  it "should be initially unpublished" do
    Post.new.published.should == false
  end
end
</code></pre>

<p>```</p>

<p>This is a unit test. It tests a single piece of functionality and will
fail for just one reason.</p>

<p>Now, here's another example:</p>

<p>```ruby</p>

<pre><code>it "should fetch published articles" do
  # ?
end
</code></pre>

<p>```</p>

<p>```ruby</p>

<pre><code># post.rb
class Post &lt; ActiveRecord::Base
  def self.published
    where("published_at &lt;= ?", Time.now)
  end
end
</code></pre>

<p>```</p>

<p>How should you implement this spec?</p>

<p>If you were trying to avoid hitting the database you might intercept the
<code>where</code> call and assert the parameters passed to it. But surely this
isn't the only way you could implement this method giving the same
behavior.  You might use <code>scopes</code> or another <code>where</code> call might actually
be added later that doesn't affect the outcome of this method in any way
that this test is concerned about.</p>

<p>```ruby</p>

<pre><code>it "should fetch published articles" do
  3.times { Factory.create :article }
  future_post = Factory.create :article, :published_at =&gt; 2.days.from_now
  posts = Post.published
  posts.size.should == 3
  post.should_not include future_post
end
</code></pre>

<p>```</p>

<p>This test hits the database (numerous times, in fact) but it's testing
<em>exactly</em> the behavior we need.  We aren't testing implementation, we're
testing that the behavior works as intended.  If we somehow muck with
the query, breaking it, this test will fail.  If we change the
implementation to use some other query means (scopes or whatever) this
test will still pass.</p>

<p>Is it so bad that the test hits the database?</p>

<p>There are drawbacks of course:</p>

<ul>
<li>The test requires a database, thus you have to migrate</li>
<li>The <code>database_cleaner</code> gem will have to be present to clean out the
database before each run</li>
<li>These database statements make the test suite a LOT slower, so large
test suites will eventually suffer.</li>
<li>The tests could fail if the database isn't present (or migrated), or
if the query is incorrect.  But this isn't likely to happen since
we're using a tested framework (ActiveRecord).</li>
</ul>


<p>Ultimately this isn't really a unit test at all.  It's an integration
test.  So is <code>spec/models/post_spec.rb</code> the wrong place for this stuff?</p>

<p>The question eventually comes down to this: <em>What is more valuable?  A
fast, isolated test suite?  Or a test suite that breaks for the right
reasons?</em></p>

<h2>Don't throw out good practices just because it's Ruby</h2>

<p>I think it's important to be cognizant of software paradigms and use
them where they make sense. It's also important to recognize when
practices are being ignored because "celebrities" aren't touting them.</p>

<p>It is still valuable, however, to keep a fresh eye on old assumptions. Don't
always take things as gospel just because that's the way they have
always been. One
of the things I love about the Ruby community is how willing people are
to rock the boat &amp; try something new.</p>
]]></content>
  </entry>
  
</feed>
