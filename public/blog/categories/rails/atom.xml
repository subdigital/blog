<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Fickle Bits]]></title>
  <link href="http://benscheirman.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://benscheirman.com/"/>
  <updated>2012-07-14T08:29:48-05:00</updated>
  <id>http://benscheirman.com/</id>
  <author>
    <name><![CDATA[Ben Scheirman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Serving Assets from S3 on Heroku]]></title>
    <link href="http://benscheirman.com/2012/07/serving-assets-from-s3-on-heroku/"/>
    <updated>2012-07-07T11:17:00-05:00</updated>
    <id>http://benscheirman.com/2012/07/serving-assets-from-s3-on-heroku</id>
    <content type="html"><![CDATA[<p>Recently I changed <a href="http://nsscreencast.com">NSScreencast</a> to use a <a href="http://en.wikipedia.org/wiki/Content_delivery_network">CDN</a>
to serve up assets from a different, faster server.</p>

<h2>Why use a CDN?</h2>

<p>Using a CDN has numerous benefits.  First, and foremost, this alleviates a bunch of secondary requests that
would normally hit your webserver.  Loading the home page of NSScreencast loads more than a dozen images, stylesheets, and
javascript files.  When deploying to Heroku this can be especially problematic as each asset request will occupy one of your
dynos for a short time.  In the spirit of maximizing your free dyno on Heroku, not sending these requests to your app is definitely
a big win.</p>

<p>In addition, most browsers have a setting that limits the number of connections (usually 2) that it will open
in parallel to a given domain.  By using a CDN, you can increase the number of parallel requests
because these assets are not served up by your application's domain.</p>

<p>It's also a common practice to use dns to "alter" the domain so that you can maximize this parallelization.</p>

<h2>Using the asset sync gem</h2>

<p>Following the instructions on <a href="https://devcenter.heroku.com/articles/cdn-asset-host-rails31">Heroku's Devcenter article</a> I
decided to use the <code>asset_sync</code> gem.  This gem will upload your compiled assets to your preferred CDN (any file storage server that
<a href="https://github.com/fog/fog/">fog</a> supports).  In my case, I wanted to use S3.</p>

<p>The first step is adding this gem to your <code>Gemfile</code>:</p>

<p><code>ruby
group :assets do
  # other asset gems
  gem 'asset_sync'
end
</code></p>

<p>It's important to put this in your asset group, as your running app doesn't need to load this into memory.</p>

<p>Then you need to configure the gem.  I found Heroku's instructions to be lacking here, as I had to dig into
the <a href="https://github.com/rumblelabs/asset_sync"><code>asset_sync</code> github page</a> to make this work.</p>

<p>Add a file called <code>config/initializers/asset_sync.rb</code> to your app:</p>

<p>```ruby</p>

<h1>Since this gem is only loaded with the assets group, we have to check to</h1>

<h1>see if it's defined before configuring it.</h1>

<p>if defined?(AssetSync)
  AssetSync.configure do |config|</p>

<pre><code>config.fog_provider = 'AWS'
config.aws_access_key_id = ENV['AWS_ACCESS_KEY_ID']
config.aws_secret_access_key = ENV['AWS_SECRET_ACCESS_KEY']
config.fog_directory = ENV['FOG_DIRECTORY']

# Fail silently.  Useful for environments such as Heroku
config.fail_silently = true
</code></pre>

<p>  end
end
```</p>

<p>That last config line is important.  When you deploy to Heroku, your app's assets will get precompiled.  But because Heroku
doesn't initialize your app on precompile, none of your settings will be available.  Instead we'll have to run the precompile again,
manually, to get AssetSync to kick in.</p>

<h2>Setting up the configuration with Heroku San</h2>

<p>Since I like to have multiple environments, I use <a href="https://github.com/fastestforward/heroku_san"><code>heroku_san</code></a> to manage them, including
the environment variables.</p>

<p>Inside of <code>config/heroku.yml</code>, set up the following for each environment:</p>

<p>```</p>

<pre><code>FOG_PROVIDER: "AWS"
FOG_DIRECTORY: "nsscreencast-assets"
AWS_ACCESS_KEY_ID: "&lt;your access key&gt;"
AWS_SECRET_ACCESS_KEY: "..."
</code></pre>

<p>```</p>

<h2>Configuring Your Rails app to use S3 as an Asset Host</h2>

<p>In your <code>config/production.rb</code> (and <code>staging.rb</code> if you have one), make sure to add the
following line to allow Rails to generate the appropriate links for your assets:</p>

<p>```ruby
  config.action_controller.asset_host = Proc.new do |source, request|</p>

<pre><code>scheme = request.ssl? ? "https" : "http"
"#{scheme}://#{ENV['FOG_DIRECTORY']}.s3.amazonaws.com"
</code></pre>

<p>  end
```</p>

<p>This will allow your app to serve up the URLs using SSL if the request is coming via SSL.  Doing
this can avoid warnings in the browser that your app contains secure and unsecure content.</p>

<h2>Testing it all out</h2>

<p>If all of this is configured correctly, you can test it out by doing a push...</p>

<p><code>
git push heroku master
</code></p>

<p>You'll see the asset precompile going on in the logs, and likely an error related to AssetSync.  This is fine (and
in fact, this tripped me up at first).  Once
the deploy has completed, you'll have to run this command to upload your assets:</p>

<p><code>
heroku run rake assets:precompile --app &lt;yourapp&gt;
</code></p>

<p>Doing this, you should see something like the following output:</p>

<p><code>
Precompiling assets...
Uploading: application.css
Uploading: application.css.gz
Uploading: image1.png
Uploading: image2.png
...
</code></p>

<h2>Set up Heroku San to do this on every deploy</h2>

<p>I'd likely forget to run this command every once in a while, so I set up Heroku San to run this command
after every deploy.</p>

<p>To do this, add a new rake task in your app (<code>lib/tasks/deploy.rake</code>):</p>

<p>```ruby
task :after_deploy do
  HerokuSan.project.each_app do |stage|</p>

<pre><code>puts "---&gt; Precompiling asssets &amp; uploading to the CDN"
system("heroku run rake assets:precompile --app #{stage.app}")
</code></pre>

<p>  end
end
```</p>

<p>Now when you run your deploy via <code>rake production deploy</code> this will happen automatically.</p>

<h2>So what's the net result?</h2>

<p>Doing this alleviated nearly 30 secondary requests to my application for each page load.  That alone is pretty huge.  Also, S3 is
much faster at serving these assets than nginx is (at least via a Heroku app on 1 dyno).</p>

<p>I tested this before and after by clearing the cache and doing a fresh page load.  Using the Chrome Inspector, I looked at the time to load the page and all assets.
Here are my findings:</p>

<table style="margin: 25px;">
  <tr>
    <td style="border: solid 1px #ddd; padding: 3px 7px;">
      <strong>Before</strong> (<em>serving assets with no CDN</em>)
    </td>
    <td style="border: solid 1px #ddd; padding: 3px 7px;">3.27 seconds</td>
  </tr>
  <tr>
    <td style="border: solid 1px #ddd; padding: 3px 7px;"><strong>After</strong>
    (<em>using S3 as a CDN</em>)
    </td>
    <td style="border: solid 1px #ddd; padding: 3px 7px;">1.07 seconds</td>
  </tr>
</table>


<p>That's a huge gain for a minor change in your application &amp; deployment process.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Is Rails Exempt?]]></title>
    <link href="http://benscheirman.com/2011/08/is-rails-exempt-from-software-principles/"/>
    <updated>2011-08-26T07:58:00-05:00</updated>
    <id>http://benscheirman.com/2011/08/is-rails-exempt-from-software-principles</id>
    <content type="html"><![CDATA[<p>If you've been following the Ruby community recently, you'd notice that
there's are people calling our Rails (and Rails developers) for treating
Rails as if it is somehow <em>exempt</em> from long-standing software
principles.</p>

<p><a href="http://osherove.com/">Roy Osherove</a>, a fairly well-known .NET developer and author of The <a href="http://artofunittesting.com/">Art of Unit Testing</a>, ventured into Ruby-land
recently and commented on twitter about how Rails's
definition of unit &amp; integration is quite different from his.</p>

<p><img class="tweet" src="/images/rails-unit-integration-tweet.png"></p>

<p>I have to agree with Roy. Those in the TDD camp in .NET understood the
difference and were (from my experience) fairly cognizent of isolating
concerns and not mixing the 2 concepts. Some even go as far as to
isolate integration tests into their own assembly, providing a physical
separation further guaranteeing that a unit test project won't touch
web services or the database.</p>

<p>It's easy to assume from the outside that the Rails is just testing
nirvana and that <em>everyone</em> does it and it's so easy.  Unfortunately it's
just not the truth.  Rails (and Ruby) make testing really easy but that
means it's even easier to do the wrong thing as well.</p>

<h2>Legacy Rails Apps</h2>

<p>Now that Rails is (gasp) over 7 years old you're starting to see some
real legacy Rails applications out in the wild.</p>

<p><a href="http://twitter.com/avdi">Avdi Grimm</a> has a <a href="http://avdi.org/devblog/2011/08/22/your-code-is-my-hell/">good post</a> on the topic of how many of the Rails apps he comes to work on are in poor shape, technically.</p>

<blockquote><p>Here are a few examples, just to give you an idea of what I’m talking about:</p>

<p>“Design Patterns are a Java thing. In Ruby you just write code.”</p>

<p>“The warnings Ruby produces are dumb; just disable them.”</p>

<p>“Sure they aren’t technically Unit Tests, but isolating objects turned out to be kind of hard and besides nobody else is doing it.”</p>

<p>“Stuff like the Law of Demeter isn’t really as important in Ruby code”</p>

<p>“That’s only a problem in large projects” (implying that this project will never become large).</p></blockquote>

<p>I've certainly been guilty of some of this. Rails makes it easy to do
things that can turn out to be problematic. As with anything, you have
to be disciplined to notice the warning signs and act accordingly.</p>

<p>When testing is painful, you're likely making mistakes. Some common
pain-points that I've experienced are:</p>

<ul>
<li>No tests - the app is hard to test because the design is poor. Classes
are too tightly coupled and don't have clear delineation of
responsibilities.</li>
<li>Tests break for unrelated reasons - the tests are covering too much
behavior, so when a single behavior changes, many tests break.</li>
<li>Tests break when implementation changes - the tests are probably
utilizing too much mocking &amp; stubbing. The tests are coupled heavily
to a particular implementation.</li>
<li>Unclear what the problem is when a test breaks - Tests are probably
too coarse-grained and may contain too many assertions per test.</li>
</ul>


<p>These are just a sampling of what I've personally observed.</p>

<p>So why do many Rails developers ignore these concepts?</p>

<h2>Pragmatism at work</h2>

<p>Many rails tutorials (and the default Rails template) treats model tests
as <em>unit</em> tests. Since Rails models are by default based on Active
Record, they have data access baked into their core.  Doing proper unit
testing means you're testing a logical unit.  If your test involves a
model operation that requires a database round-trip, that's technically
an <em>integration</em> test.  But does it really matter?</p>

<p>Most Rails developers will tell you no. Consider this spec:</p>

<p>```ruby</p>

<pre><code>describe Post do
  it "should be initially unpublished" do
    Post.new.published.should == false
  end
end
</code></pre>

<p>```</p>

<p>This is a unit test. It tests a single piece of functionality and will
fail for just one reason.</p>

<p>Now, here's another example:</p>

<p>```ruby</p>

<pre><code>it "should fetch published articles" do
  # ?
end
</code></pre>

<p>```</p>

<p>```ruby</p>

<pre><code># post.rb
class Post &lt; ActiveRecord::Base
  def self.published
    where("published_at &lt;= ?", Time.now)
  end
end
</code></pre>

<p>```</p>

<p>How should you implement this spec?</p>

<p>If you were trying to avoid hitting the database you might intercept the
<code>where</code> call and assert the parameters passed to it. But surely this
isn't the only way you could implement this method giving the same
behavior.  You might use <code>scopes</code> or another <code>where</code> call might actually
be added later that doesn't affect the outcome of this method in any way
that this test is concerned about.</p>

<p>```ruby</p>

<pre><code>it "should fetch published articles" do
  3.times { Factory.create :article }
  future_post = Factory.create :article, :published_at =&gt; 2.days.from_now
  posts = Post.published
  posts.size.should == 3
  post.should_not include future_post
end
</code></pre>

<p>```</p>

<p>This test hits the database (numerous times, in fact) but it's testing
<em>exactly</em> the behavior we need.  We aren't testing implementation, we're
testing that the behavior works as intended.  If we somehow muck with
the query, breaking it, this test will fail.  If we change the
implementation to use some other query means (scopes or whatever) this
test will still pass.</p>

<p>Is it so bad that the test hits the database?</p>

<p>There are drawbacks of course:</p>

<ul>
<li>The test requires a database, thus you have to migrate</li>
<li>The <code>database_cleaner</code> gem will have to be present to clean out the
database before each run</li>
<li>These database statements make the test suite a LOT slower, so large
test suites will eventually suffer.</li>
<li>The tests could fail if the database isn't present (or migrated), or
if the query is incorrect.  But this isn't likely to happen since
we're using a tested framework (ActiveRecord).</li>
</ul>


<p>Ultimately this isn't really a unit test at all.  It's an integration
test.  So is <code>spec/models/post_spec.rb</code> the wrong place for this stuff?</p>

<p>The question eventually comes down to this: <em>What is more valuable?  A
fast, isolated test suite?  Or a test suite that breaks for the right
reasons?</em></p>

<h2>Don't throw out good practices just because it's Ruby</h2>

<p>I think it's important to be cognizant of software paradigms and use
them where they make sense. It's also important to recognize when
practices are being ignored because "celebrities" aren't touting them.</p>

<p>It is still valuable, however, to keep a fresh eye on old assumptions. Don't
always take things as gospel just because that's the way they have
always been. One
of the things I love about the Ruby community is how willing people are
to rock the boat &amp; try something new.</p>
]]></content>
  </entry>
  
</feed>
