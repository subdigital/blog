--- 
layout: post
title: On Fluent Interfaces and Friction
date: 2007-11-9
comments: true
link: false
---
So I decided to start that NHibernate Mapping DSL project andopen-source it.&nbsp; Right now it doesn't do anything, but you're free totake a look at <a href="http://www.assembla.com/space/nhibernate-mapping">http://www.assembla.com/space/nhibernate-mapping</a><br><br>I wrote all of this code test-first, and it allowed me to tackle theinterface and flow the way I thought might be useful.&nbsp; I ended up withsomething that was mildly usable like this:<br><br>{% codeblock %}<span style="color: Black; background-color: transparent; font-family: Courier New; font-size: 11px;">IMapping mapping <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> Mapping.For&lt;Product&gt;()<br> .Identity(<span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">"Id"</span>)<br> .Property(<span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">"Name"</span>)<br> .Property(<span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">"Price"</span>)<br> .Map();</span>{% endcodeblock %}<br>So this allows me to quickly accept the defaults of the mappings, so NHibernate will assume that I have ...<br><ul><li>the column names are the same as the property names<br></li><li>the type of the column matches the type of the property and it can be picked up via reflection</li><li>the identity generator of the primary key is Identity</li><li>the identity/properties have setters</li><li>the "Name" and "Price" columns are nullable</li></ul>This isn't always true of course, so we need to be able to specify where we deviate from the defaults.&nbsp; So how can we accomplish this using a fluent interface?&nbsp; We could resort to adding more overloads to the Identity() method, so you might have....<br><br>{% codeblock %}<span style="color: Black; background-color: transparent; font-family: Courier New; font-size: 11px;">IMapping mapping <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> Mapping.For&lt;Product&gt;()<br> .Identity(<span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">"Id"</span>, <span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">"product_id"</span>, Access.NoSetterCamelcaseUnderscore, Generator.Native)<br> .Property(<span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">"Name"</span>, <span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">"product_name"</span>, <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">false</span>)<br> .Property(<span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">"Price"</span>, <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">false</span>)<br> .Map();<br></span>{% endcodeblock %}But we don't know how many settings the user might want to specify.&nbsp; If we have 4 simple, independent settings, then we'd have to support 4! method overload options!&nbsp; Yuck!<br><br>{% codeblock %}<span style="color: Black; background-color: transparent; font-family: Courier New; font-size: 11px;"><span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">public</span> IPropertySpecificationPredicate Property(<span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">string</span> name);<br><span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">public</span> IPropertySpecificationPredicate Property(<span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">string</span> name, <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">string</span> columnName);<br><span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">public</span> IPropertySpecificationPredicate Property(<span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">string</span> name, <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">string</span> columnName, DbType type);<br><span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">public</span> IPropertySpecificationPredicate Property(<span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">string</span> name, <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">string</span> columnName, DbType type, <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">int</span> length);<br><span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">public</span> IPropertySpecificationPredicate Property(<span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">string</span> name, <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">string</span> columnName, <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">bool</span> nullable);<br>...</span>{% endcodeblock %}This is just the beginning.&nbsp; What if you wanted to only specify the property name and the nullability?&nbsp; We quickly end up in an anti-pattern I like to call <b>overload explosion</b>.&nbsp; <br><br>We can do a bit better, right?&nbsp; I started to gather my thoughts and came up with this syntax:<br><br>{% codeblock %}<span style="color: Black; background-color: transparent; font-family: Courier New; font-size: 11px;">IMapping mapping <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> Mapping.For&lt;Product&gt;()<br>.Identity(<span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">"Id"</span>)<br>.Column(<span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">"product_id"</span>)<br>.Generator(Generator.Native)<br>.Map();</span>{% endcodeblock %}So now the Identity() method takes a single parameter, the name of the property.&nbsp; Anything else is optional.&nbsp; The return type is now something like an IIdentityBuilder interface, which accepts methods on altering the identity object that its building.&nbsp; Here you can see that we only specified the settings that we wanted, nothing else.&nbsp; We still had to have a way to "pop" the current object (and thus the entire mapping) so that we can indicate to the builder that we are done building the property and you can return the IMapping object next.&nbsp; This feels awkward for now, but for now it's ok.<br><br>Let's extend this pattern.&nbsp; Once I'm working with the IMappingBuilder interface, I can now see methods called Generator(), Access(), Column(), etc.&nbsp; There's nothing there to prevent me from calling .Column("...").Column("...").Column("...").Column("...") which I guess isn't such a big deal.&nbsp; All it's doing is setting the column property of this object we're building.<br><br>Now I'm noticing that there has to be a spot where the user gets finished with the mapping identity and now has some choices.&nbsp; The obvious next operation would be to create a property, but how do I pop the current context and start working on a new one?<br><br>Maybe something like this?<br><br>{% codeblock %}<span style="color: Black; background-color: transparent; font-family: Courier New; font-size: 11px;">IMapping mapping <span style="color: Red; background-co
lor: transparent; font-family: Courier New; font-size: 11px;">=</span> Mapping.For&lt;Product&gt;().Identity(<span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">"Id"</span>).Column(<span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">"product_id"</span>).Generator(Generator.Native).AndProperty(<span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">"Name"</span>).Nullable(<span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">false</span>).Map();</span>{% endcodeblock %}<p></p>I'm already started to notice that my identity and property elements are getting lost in the noise.&nbsp; If I keep up this pattern not only do I have TONS of ISomethingPredicateBuilder objects, I also remember that it's not only properties that I can add at any time.&nbsp; I could add a Bag, a Set, a List, or any number of other mapping elements.<br><br>Another route I might take is using anonymous to provide me with the flexibility of code within the interface.&nbsp; Take a look:<br><br>{% codeblock %}<span style="color: Black; background-color: transparent; font-family: Courier New; font-size: 11px;">IMapping mapping <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> Mapping.For&lt;Product&gt;().Identity(<span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">"Id"</span>, <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">delegate</span>(Identity i) { i.column <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> <span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">"product_id"</span>; i.generator <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> Generator.Native;}).AndProperty(<span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">"Name"</span>, <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">delegate</span>(Property p) { p.column <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> <span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">"product_name"</span>; p.nullable <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">false</span>;}).Map();</span>{% endcodeblock %}Here I have a lot more flexibility over the different ways that I define various mapping elements.&nbsp; The only part of this that is really cumbersome is the delegate syntax itself.<br><br>This is probably where Boo or Ruby would come in and save the day because of it's super-dynamicness-flexibility-extraordinaire, but I'd like to see how far I can push C# for now.&nbsp; At least until C# 3.0 comes out, where I'll get object initializers, lamba expressions, and a few other neat tricks that really make this stuff more fun to sculpt.<br><br>What about you?&nbsp; What types of syntax do you find most readable, usable?<br>
