--- 
layout: post
title: "Prototype Protips #2 - Preventing Memory Leaks & Creating Objects"
date: 2008-7-4
comments: true
link: false
---
<p>It&rsquo;s been almost a year since I posted <a href="http://www.flux88.com/PrototypeScriptaculousProtips1.aspx" target="_blank">Prototype Protips #1</a> (and since then I have grown quite fond of <a href="http://jquery.com/" target="_blank">jQuery</a>), but <a href="http://prototypejs.org/" target="_blank">prototype</a> remains an excellent, choice for elegant javascript development still today.</p><p>If you aren&rsquo;t taking advantage of an advanced javascript library, then you are not only missing out on cleaner code, but you are quite possibly likely introducing memory leaks through unfreed event handlers!&nbsp; IE6 is notoriously bad at this, and you have to take extra caution in EVERY event handler to make sure you aren&rsquo;t leaking memory.</p><p>Douglas Crockford, describes memory leaks in IE&nbsp;like this:</p><blockquote><p>When a DOM object contains a reference to a <a href="http://www.crockford.com/javascript/">JavaScript</a> object (such an event handling function), and when that JavaScript object contains a reference to that DOM object, then a cyclic structure is formed. This is not in itself a problem. At such time as there are no other references to the DOM object and the event handler, then the garbage collector (an automatic memory resource manager) will reclaim them both, allowing their space to be reallocated. The JavaScript garbage collector understands about cycles and is not confused by them. Unfortunately, IE's DOM is not managed by JScript. It has its own memory manager that does not understand about cycles and so gets very confused. As a result, when cycles occur, memory reclamation does not occur. The memory that is not reclaimed is said to have leaked. Over time, this can result in memory starvation.</p></blockquote><p>It takes a seriously smart person to understand closures in javascript and why they cause memory leaks.&nbsp; Personally I&rsquo;m glad someone else has figured it out!&nbsp; But it doesn&rsquo;t mean we can&rsquo;t protect ourselves and just do things the safe way.</p><p>That&rsquo;s why using a good javascript library is such a no-brainer.&nbsp; In prototype, you wire up events like this:</p>{% codeblock %}Event.observe(window, 'load', function() {//do something when the DOM is loaded});{% endcodeblock %}<p>This is a safe way of adding a load event to the page without erasing any previous load events that were wired up.&nbsp; (<em>Anyone ever had ASP.NET erase one of your button click handlers?&nbsp; I have&hellip;)</em></p><p>`$()` extended elements also get this ability.&nbsp; Say you have a button on the page like this:</p>{% codeblock %}<span class="kwrd">&lt;</span><span class="html">input</span> <span class="attr">type</span><span class="kwrd">="button"</span> <span class="attr">id</span><span class="kwrd">="activate"</span> <span class="attr">value</span><span class="kwrd">="Activate the Reactor!"</span> <span class="kwrd">/&gt;</span>{% endcodeblock %}<p>You can wire up a click even to this button by simply&hellip;</p>{% codeblock %}$(<span class="str">'activate'</span>).observe(<span class="str">'click'</span>, function() { alert(<span class="str">'RUN!'</span>);});{% endcodeblock %}<p>Wiring up events&nbsp;in this manner will help keep&nbsp;you from leaking memory and generally provides better syntax.</p><p><strong>Objects</strong></p><p>Sometimes when you are writing code that has complex javascript, the functions seem to relate, however they are just placed in file in global scope.&nbsp; This breaks down when you have lots of scripts from various components on a page and sooner or later things will start to conflict.&nbsp; I mean, how many `init()` methods can you have on a page?&nbsp; Would you write a C# program with nothing but 1 class?</p><p>Grouping this functionality into javascript classes can really help streamline and encapsulate your javascript code.&nbsp; This is incredibly useful when you have a script for a control on a page but you need to support having multiple instances of that control on the same page.&nbsp; On top of that, with ASP.NET you have to deal with the id munging, so things become even harder.</p><p>In prototype (as of 1.6), you create a class like this:</p>{% codeblock %}var Person = Class.create({initialize: function(name, ) {<span class="kwrd">this</span>.name = name;},greet: function() {alert(<span class="str">"Hello, "</span> + <span class="kwrd">this</span>.name + <span class="str">"!"</span>);}});<span class="rem">//create a person instance like this:</span>var joe = <span class="kwrd">new</span> Person(<span class="str">"Joe"</span>);joe.greet(); // --&gt;<span class="str">"Hello, Joe!"</span>{% endcodeblock %}<p>The initialize() method is like a&nbsp;constructor.&nbsp; It will&nbsp;get called when you&nbsp;&ldquo;new&rdquo; up your&nbsp;javascript class.&nbsp; You can extend this&nbsp;object and add more functionality to it pretty easily.</p><p><strong>Using Javascript Classes for your Components</strong></p><p>Let&rsquo;s say you want to create a type-ahead auto-complete textbox using ASP.NET.&nbsp; Ignoring some of the canned-solutions for the sake of discussion, let&rsquo;s also say we have to write it from scratch.&nbsp; We&rsquo;ll need some script to monitor the value of the textbox, and to send an ajax request with the current value, and to handle the response &amp; fill in a list of values.</p><p>Here&rsquo;s an example of how (a very crude) implementation might look:</p><p>&nbsp;</p>{% codeblock %}<span class="rem">//referenced (or rendered) only once</span>var TypeAheadTextbox = Class.create({initialize: function(textbox_id, indicator_id, results_id) {<span class="kwrd">this</span>.textbox = $(textbox_id);<span class="kwrd">this</span>.indicator = $(indicator_id);<span class="kwrd">this</span>.results = $(results_id);<span class="rem">//use .bindAsEventListener to preserve the 'this' pointer</span><span class="kwrd">this</span>.textbox.observe(<span class="str">'keyup'</span>, <span class="kwrd">this</span>.processKey.bindAsEventListener(<span class="kwrd">this</span>));},processKey: function() {<span class="rem">//ignoring the interval, we'll just fire an ajax request for every letter</span>var <span class="kwrd">value</span> = $F(<span class="kwrd">this</span>.textbox);<span class="kwrd">this</span>.indicator.show();<span class="kwrd">new</span> Ajax.Request(<span class="str">'/pirate_ships/find'</span>, {method: <span class="str">'get'</span>,<span class="kwrd">params</span>: <span class="str">'filter='</span> + <span class="kwrd">value</span>,onComplete: function() { <span class="kwrd">this</span>.indicator.hide(); },onFailure: function(e) { alert(<span class="str">"Error with ajax request: "</span> + e); },onSuccess: function(response) {<span class="kwrd">this</span>.results.innerHTML = response.responseText;}})}});<span class="rem">//initializing multiple controls</span>Event.observe(window, <span class="str">'load'</span>, function(){var textbox1_autocomplete = <span class="kwrd">new</span> TypeAheadTextbox(<span class="str">'&lt;%= txtbox1.ClientID %&gt;'</span>, <span class="str">'&lt;%= indicator1.ClientID %&gt;'</span>,<span class="str">'&lt;%= results1.ClientID %&gt;'</span>);var textbox2_autocomplete = <span class="kwrd">new</span> TypeAheadTextbox(<span class="str">'&lt;%= txtbox2.ClientID %&gt;'</span>, <span class="str">'&lt;%= indicator2.ClientID %&gt;'</span>,<span class="str">'&lt;%= results2.ClientID %&gt;'</span>);});{% endcodeblock %}<p>Of course this code is incomplete, but it&rsquo;s definitely a start, and it amazes me at how simple it is.&nbsp; One hiccup that I ran across doing something similar was the .bindAsEventListener noise.&nbsp; You can read about that here, but&nbsp;the short of it&nbsp;is that&nbsp;javascript will lose &lsquo;this&rsquo; in those types of&nbsp;event handlers.&nbsp; Using .bindAsEventListener will fix this for you.Another trick is to use something like:</p>{% codeblock %}initialize: function(msg) {var self = <span class="kwrd">this</span>; <span class="rem">//for use later</span><span class="kwrd">this</span>.msg = msg;},foo: function() {alert(self.msg);}{% endcodeblock %}<p>We&rsquo;ve al
so isolated the area where we need to pass in the generated ClientID of the controls we want to interact with.&nbsp; This snippet of code can reside on the page, whereas the rest of the code reside ina separate file.</p><p>I&rsquo;m no javascript ninja, but I have a vast appreciation for all that these libraries give us.&nbsp; Yet it still amazes me that a lot of people don&rsquo;t use them!&nbsp; So go tell a friend or co-worker about the benefits of a good javascript libary.</p>
